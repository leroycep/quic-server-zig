const std = @import("std");
const mem = std.mem;
const crypto = std.crypto;
const ArrayList = std.ArrayList;
const HkdfSha256 = crypto.kdf.hkdf.HkdfSha256;
const Aes128 = crypto.core.aes.Aes128;
const Aes128Gcm = crypto.aead.aes_gcm.Aes128Gcm;
const VariableLengthVector = @import("./variable_length_vector.zig").VariableLengthVector;

const EndpointKind = enum {
    server,
    client,
};

/// Derives server_initial_secret from the given client Destination Connection ID,
/// writing the result into `out`.
/// https://www.rfc-editor.org/rfc/rfc9001#name-initial-secrets
pub fn deriveServerInitialSecret(out: *[32]u8, client_destination_connection_id: []const u8) !void {
    try deriveInitialSecretInner(.server, out, client_destination_connection_id);
}

/// Derives client_initial_secret from the given client Destination Connection ID,
/// writing the result into `out`.
/// https://www.rfc-editor.org/rfc/rfc9001#name-initial-secrets
pub fn deriveClientInitialSecret(out: *[32]u8, client_destination_connection_id: []const u8) !void {
    try deriveInitialSecretInner(.client, out, client_destination_connection_id);
}

fn deriveInitialSecretInner(comptime kind: EndpointKind, out: *[32]u8, client_destination_connection_id: []const u8) !void {
    const initial_secret = deriveCommonInitialSecret(client_destination_connection_id);
    const label = switch (kind) {
        .server => "server in",
        .client => "client in",
    };
    const ctx = "";
    try hkdfExpandLabel(initial_secret, label, ctx, out);
}

/// Derives AEAD Key (key) from the given server_initial_secret,
/// writing the result into `out`.
/// TODO(magurotuna): it works well for client_initial_secret, so maybe 2nd parameter should be renamed?
pub fn deriveAeadKey(out: *[16]u8, server_initial_secret: [32]u8) !void {
    const label = "quic key";
    const ctx = "";
    try hkdfExpandLabel(server_initial_secret, label, ctx, out);
}

/// Derives Initialization Vector (IV) from the given server_initial_secret,
/// writing the result into `out`.
/// TODO(magurotuna): it works well for client_initial_secret, so maybe 2nd parameter should be renamed?
pub fn deriveInitializationVector(out: *[12]u8, server_initial_secret: [32]u8) !void {
    const label = "quic iv";
    const ctx = "";
    try hkdfExpandLabel(server_initial_secret, label, ctx, out);
}

/// Derives Header Protection Key (hp) from the given server_initial_secret,
/// writing the result into `out`.
pub fn deriveHeaderProtectionKey(out: *[16]u8, server_initial_secret: [32]u8) !void {
    const label = "quic hp";
    const ctx = "";
    try hkdfExpandLabel(server_initial_secret, label, ctx, out);
}

/// Returns a mask that is used to protect the header sent from the server.
/// TODO(magurotuna): add support for ChaCha20-Based header protection
/// https://www.rfc-editor.org/rfc/rfc9001#name-chacha20-based-header-prote
pub fn getServerHeaderProtectionMask(comptime Aes: type, client_destination_connection_id: []const u8, sample: *const [16]u8) ![5]u8 {
    return getHeaderProtectionMask(.server, Aes, client_destination_connection_id, sample);
}

/// Returns a mask that is used to protect the header sent from the client.
/// TODO(magurotuna): add support for ChaCha20-Based header protection
/// https://www.rfc-editor.org/rfc/rfc9001#name-chacha20-based-header-prote
pub fn getClientHeaderProtectionMask(comptime Aes: type, client_destination_connection_id: []const u8, sample: *const [16]u8) ![5]u8 {
    return getHeaderProtectionMask(.client, Aes, client_destination_connection_id, sample);
}

fn getHeaderProtectionMask(comptime kind: EndpointKind, comptime Aes: type, client_destination_connection_id: []const u8, sample: *const [16]u8) ![5]u8 {
    var initial_secret: [32]u8 = undefined;
    switch (kind) {
        .server => try deriveServerInitialSecret(&initial_secret, client_destination_connection_id),
        .client => try deriveClientInitialSecret(&initial_secret, client_destination_connection_id),
    }

    var hp_key: [16]u8 = undefined;
    try deriveHeaderProtectionKey(&hp_key, initial_secret);
    const ctx = Aes.initEnc(hp_key);
    var encrypted: [16]u8 = undefined;
    ctx.encrypt(&encrypted, sample);

    var ret: [5]u8 = undefined;

    comptime var i = 0;
    inline while (i < 5) : (i += 1) {
        ret[i] = encrypted[i];
    }

    return ret;
}

test "server header protection mask" {
    // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#name-server-initial
    // zig fmt: off
    const client_dcid = [_]u8{
        0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
    };
    // zig fmt: on

    // zig fmt: off
    const sample = [_]u8{
        0x2c, 0xd0, 0x99, 0x1c, 0xd2, 0x5b, 0x0a, 0xac,
        0x40, 0x6a, 0x58, 0x16, 0xb6, 0x39, 0x41, 0x00,
    };
    // zig fmt: on
    const got = try getServerHeaderProtectionMask(Aes128, &client_dcid, &sample);
    const expected = [_]u8{
        0x2e, 0xc0, 0xd8, 0x35, 0x6a,
    };
    try std.testing.expectEqualSlices(u8, &expected, &got);
}

test "client header protection mask" {
    // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#name-client-initial
    // zig fmt: off
    const client_dcid = [_]u8{
        0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
    };
    // zig fmt: on

    // zig fmt: off
    const sample = [_]u8{
        0xd1, 0xb1, 0xc9, 0x8d, 0xd7, 0x68, 0x9f, 0xb8,
        0xec, 0x11, 0xd2, 0x42, 0xb1, 0x23, 0xdc, 0x9b,
    };
    // zig fmt: on
    const got = try getClientHeaderProtectionMask(Aes128, &client_dcid, &sample);
    const expected = [_]u8{
        0x43, 0x7b, 0x9a, 0xec, 0x36,
    };
    try std.testing.expectEqualSlices(u8, &expected, &got);
}

const HkdfLabel = struct {
    length: u16,
    label: VariableLengthVector(u8, label_max_length),
    context: VariableLengthVector(u8, ctx_max_length),

    const Self = @This();

    const label_prefix = "tls13 ";
    const label_max_length = 255;
    const ctx_max_length = 255;

    fn encode(self: Self, out: []u8) !usize {
        var pos: usize = 0;
        mem.writeIntBig(u16, out[0..@sizeOf(u16)], self.length);
        pos += @sizeOf(u16);

        pos += try self.label.encode(out[pos..]);
        pos += try self.context.encode(out[pos..]);

        return pos;
    }
};

fn hkdfExpandLabel(secret: [32]u8, label: []const u8, ctx: []const u8, out: []u8) !void {
    if (HkdfLabel.label_prefix.len + label.len > HkdfLabel.label_max_length) {
        return error.LabelTooLong;
    }
    if (ctx.len > HkdfLabel.ctx_max_length) {
        return error.ContextTooLong;
    }

    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    const hkdfLabel = HkdfLabel{
        .length = @intCast(u16, out.len),
        .label = label: {
            var lbl = try ArrayList(u8).initCapacity(allocator, HkdfLabel.label_prefix.len + label.len);
            lbl.appendSliceAssumeCapacity(HkdfLabel.label_prefix);
            lbl.appendSliceAssumeCapacity(label);
            break :label .{ .data = lbl };
        },
        .context = ctx: {
            var context = try ArrayList(u8).initCapacity(allocator, ctx.len);
            context.appendSliceAssumeCapacity(ctx);
            break :ctx .{ .data = context };
        },
    };

    // TODO(magurotuna): consider more appropriate array size
    var encoded_label: [4096]u8 = undefined;
    const encoded_label_size = try hkdfLabel.encode(&encoded_label);

    HkdfSha256.expand(out, encoded_label[0..encoded_label_size], secret);
}

fn deriveCommonInitialSecret(client_destination_connection_id: []const u8) [32]u8 {
    // zig fmt: off
    const initial_salt = [_]u8{
        0x38, 0x76, 0x2c, 0xf7, 0xf5, 0x59, 0x34, 0xb3,
        0x4d, 0x17, 0x9a, 0xe6, 0xa4, 0xc8, 0x0c, 0xad,
        0xcc, 0xbb, 0x7f, 0x0a,
    };
    // zig fmt: on
    return HkdfSha256.extract(&initial_salt, client_destination_connection_id);
}

/// Decrypts payload of the packet.
/// Currently it assumes that the given packet is Initial packet sent from the client.
/// TODO(magurotuna): support all types of packets
pub fn decryptPayload(allocator: mem.Allocator, encrypted_payload: []const u8, unprotected_header: []const u8, packet_number: u32, client_destination_connection_id: []const u8) !ArrayList(u8) {
    // In AEAD_AES_128_GCM, an authentication tag is 16-octet length and present at the end of the payload.
    // https://www.rfc-editor.org/rfc/rfc5116.html#section-5.1
    // TODO(magurotuna): support others: AEAD_AES_256_GCM, AEAD_CHACHA20_POLY1305 and AEAD_AES_128_CCM.
    const tag_length = 16;
    const tag = blk: {
        var t: [tag_length]u8 = undefined;
        mem.copy(u8, &t, encrypted_payload[(encrypted_payload.len - tag_length)..]);
        break :blk t;
    };
    const encrypted_payload_without_tag = encrypted_payload[0..(encrypted_payload.len - tag_length)];

    const client_initial_secret = blk: {
        var s: [32]u8 = undefined;
        try deriveClientInitialSecret(&s, client_destination_connection_id);
        break :blk s;
    };

    const nonce = blk: {
        // https://www.rfc-editor.org/rfc/rfc9001#name-aead-usage
        //
        // The nonce, N, is formed by combining the packet protection IV with the packet number.
        // The 62 bits of the reconstructed QUIC packet number in network byte order are
        // left-padded with zeros to the size of the IV. The exclusive OR of the padded packet
        // number and the IV forms the AEAD nonce.
        const iv_length = 12;
        std.debug.assert(iv_length == Aes128Gcm.nonce_length);
        var iv: [iv_length]u8 = undefined;
        try deriveInitializationVector(&iv, client_initial_secret);
        var pn: [iv_length]u8 = undefined;
        mem.writeIntSliceBig(u32, &pn, packet_number);
        var n: [Aes128Gcm.nonce_length]u8 = undefined;
        for (n) |_, i| {
            n[i] = pn[i] ^ iv[i];
        }

        break :blk n;
    };

    const key = blk: {
        var k: [16]u8 = undefined;
        try deriveAeadKey(&k, client_initial_secret);
        break :blk k;
    };

    const decrypted_payload = blk: {
        const out = try allocator.alloc(u8, encrypted_payload_without_tag.len);
        errdefer allocator.free(out);
        try Aes128Gcm.decrypt(out, encrypted_payload_without_tag, tag, unprotected_header, nonce, key);
        break :blk ArrayList(u8).fromOwnedSlice(allocator, out);
    };
    errdefer decrypted_payload.deinit();

    return decrypted_payload;
}

test "decrypt payload of Initial packet sent from a client" {
    // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#name-client-initial

    // zig fmt: off
    const encrypted_payload = [_]u8{
                                            0xd1, 0xb1,
        0xc9, 0x8d, 0xd7, 0x68, 0x9f, 0xb8, 0xec, 0x11,
        0xd2, 0x42, 0xb1, 0x23, 0xdc, 0x9b, 0xd8, 0xba,
        0xb9, 0x36, 0xb4, 0x7d, 0x92, 0xec, 0x35, 0x6c,
        0x0b, 0xab, 0x7d, 0xf5, 0x97, 0x6d, 0x27, 0xcd,
        0x44, 0x9f, 0x63, 0x30, 0x00, 0x99, 0xf3, 0x99,
        0x1c, 0x26, 0x0e, 0xc4, 0xc6, 0x0d, 0x17, 0xb3,
        0x1f, 0x84, 0x29, 0x15, 0x7b, 0xb3, 0x5a, 0x12,
        0x82, 0xa6, 0x43, 0xa8, 0xd2, 0x26, 0x2c, 0xad,
        0x67, 0x50, 0x0c, 0xad, 0xb8, 0xe7, 0x37, 0x8c,
        0x8e, 0xb7, 0x53, 0x9e, 0xc4, 0xd4, 0x90, 0x5f,
        0xed, 0x1b, 0xee, 0x1f, 0xc8, 0xaa, 0xfb, 0xa1,
        0x7c, 0x75, 0x0e, 0x2c, 0x7a, 0xce, 0x01, 0xe6,
        0x00, 0x5f, 0x80, 0xfc, 0xb7, 0xdf, 0x62, 0x12,
        0x30, 0xc8, 0x37, 0x11, 0xb3, 0x93, 0x43, 0xfa,
        0x02, 0x8c, 0xea, 0x7f, 0x7f, 0xb5, 0xff, 0x89,
        0xea, 0xc2, 0x30, 0x82, 0x49, 0xa0, 0x22, 0x52,
        0x15, 0x5e, 0x23, 0x47, 0xb6, 0x3d, 0x58, 0xc5,
        0x45, 0x7a, 0xfd, 0x84, 0xd0, 0x5d, 0xff, 0xfd,
        0xb2, 0x03, 0x92, 0x84, 0x4a, 0xe8, 0x12, 0x15,
        0x46, 0x82, 0xe9, 0xcf, 0x01, 0x2f, 0x90, 0x21,
        0xa6, 0xf0, 0xbe, 0x17, 0xdd, 0xd0, 0xc2, 0x08,
        0x4d, 0xce, 0x25, 0xff, 0x9b, 0x06, 0xcd, 0xe5,
        0x35, 0xd0, 0xf9, 0x20, 0xa2, 0xdb, 0x1b, 0xf3,
        0x62, 0xc2, 0x3e, 0x59, 0x6d, 0x11, 0xa4, 0xf5,
        0xa6, 0xcf, 0x39, 0x48, 0x83, 0x8a, 0x3a, 0xec,
        0x4e, 0x15, 0xda, 0xf8, 0x50, 0x0a, 0x6e, 0xf6,
        0x9e, 0xc4, 0xe3, 0xfe, 0xb6, 0xb1, 0xd9, 0x8e,
        0x61, 0x0a, 0xc8, 0xb7, 0xec, 0x3f, 0xaf, 0x6a,
        0xd7, 0x60, 0xb7, 0xba, 0xd1, 0xdb, 0x4b, 0xa3,
        0x48, 0x5e, 0x8a, 0x94, 0xdc, 0x25, 0x0a, 0xe3,
        0xfd, 0xb4, 0x1e, 0xd1, 0x5f, 0xb6, 0xa8, 0xe5,
        0xeb, 0xa0, 0xfc, 0x3d, 0xd6, 0x0b, 0xc8, 0xe3,
        0x0c, 0x5c, 0x42, 0x87, 0xe5, 0x38, 0x05, 0xdb,
        0x05, 0x9a, 0xe0, 0x64, 0x8d, 0xb2, 0xf6, 0x42,
        0x64, 0xed, 0x5e, 0x39, 0xbe, 0x2e, 0x20, 0xd8,
        0x2d, 0xf5, 0x66, 0xda, 0x8d, 0xd5, 0x99, 0x8c,
        0xca, 0xbd, 0xae, 0x05, 0x30, 0x60, 0xae, 0x6c,
        0x7b, 0x43, 0x78, 0xe8, 0x46, 0xd2, 0x9f, 0x37,
        0xed, 0x7b, 0x4e, 0xa9, 0xec, 0x5d, 0x82, 0xe7,
        0x96, 0x1b, 0x7f, 0x25, 0xa9, 0x32, 0x38, 0x51,
        0xf6, 0x81, 0xd5, 0x82, 0x36, 0x3a, 0xa5, 0xf8,
        0x99, 0x37, 0xf5, 0xa6, 0x72, 0x58, 0xbf, 0x63,
        0xad, 0x6f, 0x1a, 0x0b, 0x1d, 0x96, 0xdb, 0xd4,
        0xfa, 0xdd, 0xfc, 0xef, 0xc5, 0x26, 0x6b, 0xa6,
        0x61, 0x17, 0x22, 0x39, 0x5c, 0x90, 0x65, 0x56,
        0xbe, 0x52, 0xaf, 0xe3, 0xf5, 0x65, 0x63, 0x6a,
        0xd1, 0xb1, 0x7d, 0x50, 0x8b, 0x73, 0xd8, 0x74,
        0x3e, 0xeb, 0x52, 0x4b, 0xe2, 0x2b, 0x3d, 0xcb,
        0xc2, 0xc7, 0x46, 0x8d, 0x54, 0x11, 0x9c, 0x74,
        0x68, 0x44, 0x9a, 0x13, 0xd8, 0xe3, 0xb9, 0x58,
        0x11, 0xa1, 0x98, 0xf3, 0x49, 0x1d, 0xe3, 0xe7,
        0xfe, 0x94, 0x2b, 0x33, 0x04, 0x07, 0xab, 0xf8,
        0x2a, 0x4e, 0xd7, 0xc1, 0xb3, 0x11, 0x66, 0x3a,
        0xc6, 0x98, 0x90, 0xf4, 0x15, 0x70, 0x15, 0x85,
        0x3d, 0x91, 0xe9, 0x23, 0x03, 0x7c, 0x22, 0x7a,
        0x33, 0xcd, 0xd5, 0xec, 0x28, 0x1c, 0xa3, 0xf7,
        0x9c, 0x44, 0x54, 0x6b, 0x9d, 0x90, 0xca, 0x00,
        0xf0, 0x64, 0xc9, 0x9e, 0x3d, 0xd9, 0x79, 0x11,
        0xd3, 0x9f, 0xe9, 0xc5, 0xd0, 0xb2, 0x3a, 0x22,
        0x9a, 0x23, 0x4c, 0xb3, 0x61, 0x86, 0xc4, 0x81,
        0x9e, 0x8b, 0x9c, 0x59, 0x27, 0x72, 0x66, 0x32,
        0x29, 0x1d, 0x6a, 0x41, 0x82, 0x11, 0xcc, 0x29,
        0x62, 0xe2, 0x0f, 0xe4, 0x7f, 0xeb, 0x3e, 0xdf,
        0x33, 0x0f, 0x2c, 0x60, 0x3a, 0x9d, 0x48, 0xc0,
        0xfc, 0xb5, 0x69, 0x9d, 0xbf, 0xe5, 0x89, 0x64,
        0x25, 0xc5, 0xba, 0xc4, 0xae, 0xe8, 0x2e, 0x57,
        0xa8, 0x5a, 0xaf, 0x4e, 0x25, 0x13, 0xe4, 0xf0,
        0x57, 0x96, 0xb0, 0x7b, 0xa2, 0xee, 0x47, 0xd8,
        0x05, 0x06, 0xf8, 0xd2, 0xc2, 0x5e, 0x50, 0xfd,
        0x14, 0xde, 0x71, 0xe6, 0xc4, 0x18, 0x55, 0x93,
        0x02, 0xf9, 0x39, 0xb0, 0xe1, 0xab, 0xd5, 0x76,
        0xf2, 0x79, 0xc4, 0xb2, 0xe0, 0xfe, 0xb8, 0x5c,
        0x1f, 0x28, 0xff, 0x18, 0xf5, 0x88, 0x91, 0xff,
        0xef, 0x13, 0x2e, 0xef, 0x2f, 0xa0, 0x93, 0x46,
        0xae, 0xe3, 0x3c, 0x28, 0xeb, 0x13, 0x0f, 0xf2,
        0x8f, 0x5b, 0x76, 0x69, 0x53, 0x33, 0x41, 0x13,
        0x21, 0x19, 0x96, 0xd2, 0x00, 0x11, 0xa1, 0x98,
        0xe3, 0xfc, 0x43, 0x3f, 0x9f, 0x25, 0x41, 0x01,
        0x0a, 0xe1, 0x7c, 0x1b, 0xf2, 0x02, 0x58, 0x0f,
        0x60, 0x47, 0x47, 0x2f, 0xb3, 0x68, 0x57, 0xfe,
        0x84, 0x3b, 0x19, 0xf5, 0x98, 0x40, 0x09, 0xdd,
        0xc3, 0x24, 0x04, 0x4e, 0x84, 0x7a, 0x4f, 0x4a,
        0x0a, 0xb3, 0x4f, 0x71, 0x95, 0x95, 0xde, 0x37,
        0x25, 0x2d, 0x62, 0x35, 0x36, 0x5e, 0x9b, 0x84,
        0x39, 0x2b, 0x06, 0x10, 0x85, 0x34, 0x9d, 0x73,
        0x20, 0x3a, 0x4a, 0x13, 0xe9, 0x6f, 0x54, 0x32,
        0xec, 0x0f, 0xd4, 0xa1, 0xee, 0x65, 0xac, 0xcd,
        0xd5, 0xe3, 0x90, 0x4d, 0xf5, 0x4c, 0x1d, 0xa5,
        0x10, 0xb0, 0xff, 0x20, 0xdc, 0xc0, 0xc7, 0x7f,
        0xcb, 0x2c, 0x0e, 0x0e, 0xb6, 0x05, 0xcb, 0x05,
        0x04, 0xdb, 0x87, 0x63, 0x2c, 0xf3, 0xd8, 0xb4,
        0xda, 0xe6, 0xe7, 0x05, 0x76, 0x9d, 0x1d, 0xe3,
        0x54, 0x27, 0x01, 0x23, 0xcb, 0x11, 0x45, 0x0e,
        0xfc, 0x60, 0xac, 0x47, 0x68, 0x3d, 0x7b, 0x8d,
        0x0f, 0x81, 0x13, 0x65, 0x56, 0x5f, 0xd9, 0x8c,
        0x4c, 0x8e, 0xb9, 0x36, 0xbc, 0xab, 0x8d, 0x06,
        0x9f, 0xc3, 0x3b, 0xd8, 0x01, 0xb0, 0x3a, 0xde,
        0xa2, 0xe1, 0xfb, 0xc5, 0xaa, 0x46, 0x3d, 0x08,
        0xca, 0x19, 0x89, 0x6d, 0x2b, 0xf5, 0x9a, 0x07,
        0x1b, 0x85, 0x1e, 0x6c, 0x23, 0x90, 0x52, 0x17,
        0x2f, 0x29, 0x6b, 0xfb, 0x5e, 0x72, 0x40, 0x47,
        0x90, 0xa2, 0x18, 0x10, 0x14, 0xf3, 0xb9, 0x4a,
        0x4e, 0x97, 0xd1, 0x17, 0xb4, 0x38, 0x13, 0x03,
        0x68, 0xcc, 0x39, 0xdb, 0xb2, 0xd1, 0x98, 0x06,
        0x5a, 0xe3, 0x98, 0x65, 0x47, 0x92, 0x6c, 0xd2,
        0x16, 0x2f, 0x40, 0xa2, 0x9f, 0x0c, 0x3c, 0x87,
        0x45, 0xc0, 0xf5, 0x0f, 0xba, 0x38, 0x52, 0xe5,
        0x66, 0xd4, 0x45, 0x75, 0xc2, 0x9d, 0x39, 0xa0,
        0x3f, 0x0c, 0xda, 0x72, 0x19, 0x84, 0xb6, 0xf4,
        0x40, 0x59, 0x1f, 0x35, 0x5e, 0x12, 0xd4, 0x39,
        0xff, 0x15, 0x0a, 0xab, 0x76, 0x13, 0x49, 0x9d,
        0xbd, 0x49, 0xad, 0xab, 0xc8, 0x67, 0x6e, 0xef,
        0x02, 0x3b, 0x15, 0xb6, 0x5b, 0xfc, 0x5c, 0xa0,
        0x69, 0x48, 0x10, 0x9f, 0x23, 0xf3, 0x50, 0xdb,
        0x82, 0x12, 0x35, 0x35, 0xeb, 0x8a, 0x74, 0x33,
        0xbd, 0xab, 0xcb, 0x90, 0x92, 0x71, 0xa6, 0xec,
        0xbc, 0xb5, 0x8b, 0x93, 0x6a, 0x88, 0xcd, 0x4e,
        0x8f, 0x2e, 0x6f, 0xf5, 0x80, 0x01, 0x75, 0xf1,
        0x13, 0x25, 0x3d, 0x8f, 0xa9, 0xca, 0x88, 0x85,
        0xc2, 0xf5, 0x52, 0xe6, 0x57, 0xdc, 0x60, 0x3f,
        0x25, 0x2e, 0x1a, 0x8e, 0x30, 0x8f, 0x76, 0xf0,
        0xbe, 0x79, 0xe2, 0xfb, 0x8f, 0x5d, 0x5f, 0xbb,
        0xe2, 0xe3, 0x0e, 0xca, 0xdd, 0x22, 0x07, 0x23,
        0xc8, 0xc0, 0xae, 0xa8, 0x07, 0x8c, 0xdf, 0xcb,
        0x38, 0x68, 0x26, 0x3f, 0xf8, 0xf0, 0x94, 0x00,
        0x54, 0xda, 0x48, 0x78, 0x18, 0x93, 0xa7, 0xe4,
        0x9a, 0xd5, 0xaf, 0xf4, 0xaf, 0x30, 0x0c, 0xd8,
        0x04, 0xa6, 0xb6, 0x27, 0x9a, 0xb3, 0xff, 0x3a,
        0xfb, 0x64, 0x49, 0x1c, 0x85, 0x19, 0x4a, 0xab,
        0x76, 0x0d, 0x58, 0xa6, 0x06, 0x65, 0x4f, 0x9f,
        0x44, 0x00, 0xe8, 0xb3, 0x85, 0x91, 0x35, 0x6f,
        0xbf, 0x64, 0x25, 0xac, 0xa2, 0x6d, 0xc8, 0x52,
        0x44, 0x25, 0x9f, 0xf2, 0xb1, 0x9c, 0x41, 0xb9,
        0xf9, 0x6f, 0x3c, 0xa9, 0xec, 0x1d, 0xde, 0x43,
        0x4d, 0xa7, 0xd2, 0xd3, 0x92, 0xb9, 0x05, 0xdd,
        0xf3, 0xd1, 0xf9, 0xaf, 0x93, 0xd1, 0xaf, 0x59,
        0x50, 0xbd, 0x49, 0x3f, 0x5a, 0xa7, 0x31, 0xb4,
        0x05, 0x6d, 0xf3, 0x1b, 0xd2, 0x67, 0xb6, 0xb9,
        0x0a, 0x07, 0x98, 0x31, 0xaa, 0xf5, 0x79, 0xbe,
        0x0a, 0x39, 0x01, 0x31, 0x37, 0xaa, 0xc6, 0xd4,
        0x04, 0xf5, 0x18, 0xcf, 0xd4, 0x68, 0x40, 0x64,
        0x7e, 0x78, 0xbf, 0xe7, 0x06, 0xca, 0x4c, 0xf5,
        0xe9, 0xc5, 0x45, 0x3e, 0x9f, 0x7c, 0xfd, 0x2b,
        0x8b, 0x4c, 0x8d, 0x16, 0x9a, 0x44, 0xe5, 0x5c,
        0x88, 0xd4, 0xa9, 0xa7, 0xf9, 0x47, 0x42, 0x41,
        0xe2, 0x21, 0xaf, 0x44, 0x86, 0x00, 0x18, 0xab,
        0x08, 0x56, 0x97, 0x2e, 0x19, 0x4c, 0xd9, 0x34,
    };
    // zig fmt: on

    // zig fmt: off
    const unprotected_header = [_]u8{
        0xc3, 0x00, 0x00, 0x00, 0x01, 0x08, 0x83, 0x94,
        0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08, 0x00, 0x00,
        0x44, 0x9e, 0x00, 0x00, 0x00, 0x02,
    };
    // zig fmt: on

    const packet_number = 2;

    // zig fmt: off
    const client_dcid = [_]u8{
        0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
    };
    // zig fmt: on

    const got = try decryptPayload(std.testing.allocator, &encrypted_payload, &unprotected_header, packet_number, &client_dcid);
    defer got.deinit();

    const expected = blk: {
        // Copied from https://www.rfc-editor.org/rfc/rfc9001#name-client-initial
        // zig fmt: off
        const crypto_frame = [_]u8{
            0x06, 0x00, 0x40, 0xf1, 0x01, 0x00, 0x00, 0xed,
            0x03, 0x03, 0xeb, 0xf8, 0xfa, 0x56, 0xf1, 0x29,
            0x39, 0xb9, 0x58, 0x4a, 0x38, 0x96, 0x47, 0x2e,
            0xc4, 0x0b, 0xb8, 0x63, 0xcf, 0xd3, 0xe8, 0x68,
            0x04, 0xfe, 0x3a, 0x47, 0xf0, 0x6a, 0x2b, 0x69,
            0x48, 0x4c, 0x00, 0x00, 0x04, 0x13, 0x01, 0x13,
            0x02, 0x01, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00,
            0x10, 0x00, 0x0e, 0x00, 0x00, 0x0b, 0x65, 0x78,
            0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f,
            0x6d, 0xff, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0a,
            0x00, 0x08, 0x00, 0x06, 0x00, 0x1d, 0x00, 0x17,
            0x00, 0x18, 0x00, 0x10, 0x00, 0x07, 0x00, 0x05,
            0x04, 0x61, 0x6c, 0x70, 0x6e, 0x00, 0x05, 0x00,
            0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33,
            0x00, 0x26, 0x00, 0x24, 0x00, 0x1d, 0x00, 0x20,
            0x93, 0x70, 0xb2, 0xc9, 0xca, 0xa4, 0x7f, 0xba,
            0xba, 0xf4, 0x55, 0x9f, 0xed, 0xba, 0x75, 0x3d,
            0xe1, 0x71, 0xfa, 0x71, 0xf5, 0x0f, 0x1c, 0xe1,
            0x5d, 0x43, 0xe9, 0x94, 0xec, 0x74, 0xd7, 0x48,
            0x00, 0x2b, 0x00, 0x03, 0x02, 0x03, 0x04, 0x00,
            0x0d, 0x00, 0x10, 0x00, 0x0e, 0x04, 0x03, 0x05,
            0x03, 0x06, 0x03, 0x02, 0x03, 0x08, 0x04, 0x08,
            0x05, 0x08, 0x06, 0x00, 0x2d, 0x00, 0x02, 0x01,
            0x01, 0x00, 0x1c, 0x00, 0x02, 0x40, 0x01, 0x00,
            0x39, 0x00, 0x32, 0x04, 0x08, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x04, 0x80,
            0x00, 0xff, 0xff, 0x07, 0x04, 0x80, 0x00, 0xff,
            0xff, 0x08, 0x01, 0x10, 0x01, 0x04, 0x80, 0x00,
            0x75, 0x30, 0x09, 0x01, 0x10, 0x0f, 0x08, 0x83,
            0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08, 0x06,
            0x04, 0x80, 0x00, 0xff, 0xff,
        };
        // zig fmt: on

        // PADDING frames are added to make the packet reach 1200 bytes, since clients MUST ensure that
        // UDP datagrams containing Initial packets have UDP payloads of at least 1200 bytes.
        // Note that `1162` is `1200 - header_size (22 bytes, in this case) - authentication_tag_size (16 bytes)`.
        //
        // https://www.rfc-editor.org/rfc/rfc9000.html#name-address-validation-during-c
        // https://www.rfc-editor.org/rfc/rfc9001#name-client-initial
        const padding_frames = [_]u8{0x00} ** (1162 - crypto_frame.len);

        break :blk crypto_frame ++ padding_frames;
    };

    try std.testing.expectEqualSlices(u8, &expected, got.items);
}

test "initial_secret" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        // zig fmt: off
        const client_dcid = [_]u8{
            0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
        };
        // zig fmt: on

        const got = deriveCommonInitialSecret(&client_dcid);
        // zig fmt: off
        const expected = [_]u8{
            0x7d, 0xb5, 0xdf, 0x06, 0xe7, 0xa6, 0x9e, 0x43,
            0x24, 0x96, 0xad, 0xed, 0xb0, 0x08, 0x51, 0x92,
            0x35, 0x95, 0x22, 0x15, 0x96, 0xae, 0x2a, 0xe9,
            0xfb, 0x81, 0x15, 0xc1, 0xe9, 0xed, 0x0a, 0x44,
        };
        // zig fmt: on
        try std.testing.expectEqualSlices(u8, &expected, &got);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        // zig fmt: off
        const client_dcid = [_]u8{
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        };
        // zig fmt: on

        const got = deriveCommonInitialSecret(&client_dcid);
        // zig fmt: off
        const expected = [_]u8{
            0xf0, 0x16, 0xbb, 0x2d, 0xc9, 0x97, 0x6d, 0xea,
            0x27, 0x26, 0xc4, 0xe6, 0x1e, 0x73, 0x8a, 0x1e,
            0x36, 0x80, 0xa2, 0x48, 0x75, 0x91, 0xdc, 0x76,
            0xb2, 0xae, 0xe2, 0xed, 0x75, 0x98, 0x22, 0xf6,
        };
        // zig fmt: on
        try std.testing.expectEqualSlices(u8, &expected, &got);
    }
}

test "server_initial_secret" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [32]u8 = undefined;
        // zig fmt: off
        const client_dcid = [_]u8{
            0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
        };
        // zig fmt: on
        try deriveServerInitialSecret(&out, &client_dcid);

        // zig fmt: off
        const expected = [_]u8{
            0x3c, 0x19, 0x98, 0x28, 0xfd, 0x13, 0x9e, 0xfd,
            0x21, 0x6c, 0x15, 0x5a, 0xd8, 0x44, 0xcc, 0x81,
            0xfb, 0x82, 0xfa, 0x8d, 0x74, 0x46, 0xfa, 0x7d,
            0x78, 0xbe, 0x80, 0x3a, 0xcd, 0xda, 0x95, 0x1b
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [32]u8 = undefined;
        // zig fmt: off
        const client_dcid = [_]u8{
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        };
        // zig fmt: on
        try deriveServerInitialSecret(&out, &client_dcid);

        // zig fmt: off
        const expected = [_]u8{
            0xad, 0xc1, 0x99, 0x5b, 0x5c, 0xee, 0x8f, 0x03,
            0x74, 0x6b, 0xf8, 0x30, 0x9d, 0x02, 0xd5, 0xea,
            0x27, 0x15, 0x9c, 0x1e, 0xd6, 0x91, 0x54, 0x03,
            0xb3, 0x63, 0x18, 0xd5, 0xa0, 0x3a, 0xfe, 0xb8,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}

test "client_initial_secret" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [32]u8 = undefined;
        // zig fmt: off
        const client_dcid = [_]u8{
            0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
        };
        // zig fmt: on
        try deriveClientInitialSecret(&out, &client_dcid);

        // zig fmt: off
        const expected = [_]u8{
            0xc0, 0x0c, 0xf1, 0x51, 0xca, 0x5b, 0xe0, 0x75,
            0xed, 0x0e, 0xbf, 0xb5, 0xc8, 0x03, 0x23, 0xc4,
            0x2d, 0x6b, 0x7d, 0xb6, 0x78, 0x81, 0x28, 0x9a,
            0xf4, 0x00, 0x8f, 0x1f, 0x6c, 0x35, 0x7a, 0xea,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [32]u8 = undefined;
        // zig fmt: off
        const client_dcid = [_]u8{
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        };
        // zig fmt: on
        try deriveClientInitialSecret(&out, &client_dcid);

        // zig fmt: off
        const expected = [_]u8{
            0x47, 0xc6, 0xa6, 0x38, 0xd4, 0x96, 0x85, 0x95,
            0xcc, 0x20, 0xb7, 0xc8, 0xbc, 0x5f, 0xbf, 0xbf,
            0xd0, 0x2d, 0x7c, 0x17, 0xcc, 0x67, 0xfa, 0x54,
            0x8c, 0x04, 0x3e, 0xcb, 0x54, 0x7b, 0x0e, 0xaa,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}

test "AEAD key" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [16]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0x3c, 0x19, 0x98, 0x28, 0xfd, 0x13, 0x9e, 0xfd,
            0x21, 0x6c, 0x15, 0x5a, 0xd8, 0x44, 0xcc, 0x81,
            0xfb, 0x82, 0xfa, 0x8d, 0x74, 0x46, 0xfa, 0x7d,
            0x78, 0xbe, 0x80, 0x3a, 0xcd, 0xda, 0x95, 0x1b
        };
        // zig fmt: on
        try deriveAeadKey(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xcf, 0x3a, 0x53, 0x31, 0x65, 0x3c, 0x36, 0x4c,
            0x88, 0xf0, 0xf3, 0x79, 0xb6, 0x06, 0x7e, 0x37,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [16]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8 {
            0xc0, 0x0c, 0xf1, 0x51, 0xca, 0x5b, 0xe0, 0x75,
            0xed, 0x0e, 0xbf, 0xb5, 0xc8, 0x03, 0x23, 0xc4,
            0x2d, 0x6b, 0x7d, 0xb6, 0x78, 0x81, 0x28, 0x9a,
            0xf4, 0x00, 0x8f, 0x1f, 0x6c, 0x35, 0x7a, 0xea,
        };
        // zig fmt: on
        try deriveAeadKey(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x1f, 0x36, 0x96, 0x13, 0xdd, 0x76, 0xd5, 0x46,
            0x77, 0x30, 0xef, 0xcb, 0xe3, 0xb1, 0xa2, 0x2d,
        };
        // zig fmt: on
        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [16]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0xad, 0xc1, 0x99, 0x5b, 0x5c, 0xee, 0x8f, 0x03,
            0x74, 0x6b, 0xf8, 0x30, 0x9d, 0x02, 0xd5, 0xea,
            0x27, 0x15, 0x9c, 0x1e, 0xd6, 0x91, 0x54, 0x03,
            0xb3, 0x63, 0x18, 0xd5, 0xa0, 0x3a, 0xfe, 0xb8,
        };
        // zig fmt: on
        try deriveAeadKey(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xd7, 0x7f, 0xc4, 0x05, 0x6f, 0xcf, 0xa3, 0x2b,
            0xd1, 0x30, 0x24, 0x69, 0xee, 0x6e, 0xbf, 0x90,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [16]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0x47, 0xc6, 0xa6, 0x38, 0xd4, 0x96, 0x85, 0x95,
            0xcc, 0x20, 0xb7, 0xc8, 0xbc, 0x5f, 0xbf, 0xbf,
            0xd0, 0x2d, 0x7c, 0x17, 0xcc, 0x67, 0xfa, 0x54,
            0x8c, 0x04, 0x3e, 0xcb, 0x54, 0x7b, 0x0e, 0xaa,
        };
        // zig fmt: on
        try deriveAeadKey(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xb1, 0x4b, 0x91, 0x81, 0x24, 0xfd, 0xa5, 0xc8,
            0xd7, 0x98, 0x47, 0x60, 0x2f, 0xa3, 0x52, 0x0b,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}

test "Initialization Vector (IV)" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [12]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0x3c, 0x19, 0x98, 0x28, 0xfd, 0x13, 0x9e, 0xfd,
            0x21, 0x6c, 0x15, 0x5a, 0xd8, 0x44, 0xcc, 0x81,
            0xfb, 0x82, 0xfa, 0x8d, 0x74, 0x46, 0xfa, 0x7d,
            0x78, 0xbe, 0x80, 0x3a, 0xcd, 0xda, 0x95, 0x1b
        };
        // zig fmt: on
        try deriveInitializationVector(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x0a, 0xc1, 0x49, 0x3c, 0xa1, 0x90, 0x58, 0x53,
            0xb0, 0xbb, 0xa0, 0x3e,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [12]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0xc0, 0x0c, 0xf1, 0x51, 0xca, 0x5b, 0xe0, 0x75,
            0xed, 0x0e, 0xbf, 0xb5, 0xc8, 0x03, 0x23, 0xc4,
            0x2d, 0x6b, 0x7d, 0xb6, 0x78, 0x81, 0x28, 0x9a,
            0xf4, 0x00, 0x8f, 0x1f, 0x6c, 0x35, 0x7a, 0xea,
        };
        // zig fmt: on
        try deriveInitializationVector(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xfa, 0x04, 0x4b, 0x2f, 0x42, 0xa3, 0xfd, 0x3b,
            0x46, 0xfb, 0x25, 0x5c,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [12]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0xad, 0xc1, 0x99, 0x5b, 0x5c, 0xee, 0x8f, 0x03,
            0x74, 0x6b, 0xf8, 0x30, 0x9d, 0x02, 0xd5, 0xea,
            0x27, 0x15, 0x9c, 0x1e, 0xd6, 0x91, 0x54, 0x03,
            0xb3, 0x63, 0x18, 0xd5, 0xa0, 0x3a, 0xfe, 0xb8,
        };
        // zig fmt: on
        try deriveInitializationVector(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xfc, 0xb7, 0x48, 0xe3, 0x7f, 0xf7, 0x98, 0x60,
            0xfa, 0xa0, 0x74, 0x77,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [12]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0x47, 0xc6, 0xa6, 0x38, 0xd4, 0x96, 0x85, 0x95,
            0xcc, 0x20, 0xb7, 0xc8, 0xbc, 0x5f, 0xbf, 0xbf,
            0xd0, 0x2d, 0x7c, 0x17, 0xcc, 0x67, 0xfa, 0x54,
            0x8c, 0x04, 0x3e, 0xcb, 0x54, 0x7b, 0x0e, 0xaa,
        };
        // zig fmt: on
        try deriveInitializationVector(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xdd, 0xbc, 0x15, 0xde, 0xa8, 0x09, 0x25, 0xa5,
            0x56, 0x86, 0xa7, 0xdf,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}

test "header protection key" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [16]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0x3c, 0x19, 0x98, 0x28, 0xfd, 0x13, 0x9e, 0xfd,
            0x21, 0x6c, 0x15, 0x5a, 0xd8, 0x44, 0xcc, 0x81,
            0xfb, 0x82, 0xfa, 0x8d, 0x74, 0x46, 0xfa, 0x7d,
            0x78, 0xbe, 0x80, 0x3a, 0xcd, 0xda, 0x95, 0x1b
        };
        // zig fmt: on
        try deriveHeaderProtectionKey(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xc2, 0x06, 0xb8, 0xd9, 0xb9, 0xf0, 0xf3, 0x76,
            0x44, 0x43, 0x0b, 0x49, 0x0e, 0xea, 0xa3, 0x14,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [16]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0xc0, 0x0c, 0xf1, 0x51, 0xca, 0x5b, 0xe0, 0x75,
            0xed, 0x0e, 0xbf, 0xb5, 0xc8, 0x03, 0x23, 0xc4,
            0x2d, 0x6b, 0x7d, 0xb6, 0x78, 0x81, 0x28, 0x9a,
            0xf4, 0x00, 0x8f, 0x1f, 0x6c, 0x35, 0x7a, 0xea,
        };
        // zig fmt: on
        try deriveHeaderProtectionKey(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x9f, 0x50, 0x44, 0x9e, 0x04, 0xa0, 0xe8, 0x10,
            0x28, 0x3a, 0x1e, 0x99, 0x33, 0xad, 0xed, 0xd2,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [16]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0xad, 0xc1, 0x99, 0x5b, 0x5c, 0xee, 0x8f, 0x03,
            0x74, 0x6b, 0xf8, 0x30, 0x9d, 0x02, 0xd5, 0xea,
            0x27, 0x15, 0x9c, 0x1e, 0xd6, 0x91, 0x54, 0x03,
            0xb3, 0x63, 0x18, 0xd5, 0xa0, 0x3a, 0xfe, 0xb8,
        };
        // zig fmt: on
        try deriveHeaderProtectionKey(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x44, 0x0b, 0x27, 0x25, 0xe9, 0x1d, 0xc7, 0x9b,
            0x37, 0x07, 0x11, 0xef, 0x79, 0x2f, 0xaa, 0x3d,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [16]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0x47, 0xc6, 0xa6, 0x38, 0xd4, 0x96, 0x85, 0x95,
            0xcc, 0x20, 0xb7, 0xc8, 0xbc, 0x5f, 0xbf, 0xbf,
            0xd0, 0x2d, 0x7c, 0x17, 0xcc, 0x67, 0xfa, 0x54,
            0x8c, 0x04, 0x3e, 0xcb, 0x54, 0x7b, 0x0e, 0xaa,
        };
        // zig fmt: on
        try deriveHeaderProtectionKey(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x6d, 0xf4, 0xe9, 0xd7, 0x37, 0xcd, 0xf7, 0x14,
            0x71, 0x1d, 0x7c, 0x61, 0x7e, 0xe8, 0x29, 0x81,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}
